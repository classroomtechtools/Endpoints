

<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
      modules/Library.js - Documentation
  </title>

  <link href="https://www.braintreepayments.com/images/favicon-ccda0b14.png" rel="icon" type="image/png">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>

  <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
  <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  

  

  <!-- start Mixpanel -->
  <script type="text/javascript">(function(e,a){if(!a.__SV){var b=window;try{var c,l,i,j=b.location,g=j.hash;c=function(a,b){return(l=a.match(RegExp(b+"=([^&]*)")))?l[1]:null};g&&c(g,"state")&&(i=JSON.parse(decodeURIComponent(c(g,"state"))),"mpeditor"===i.action&&(b.sessionStorage.setItem("_mpcehash",g),history.replaceState(i.desiredHash||"",e.title,j.pathname+j.search)))}catch(m){}var k,h;window.mixpanel=a;a._i=[];a.init=function(b,c,f){function e(b,a){var c=a.split(".");2==c.length&&(b=b[c[0]],a=c[1]);b[a]=function(){b.push([a].concat(Array.prototype.slice.call(arguments,
  0)))}}var d=a;"undefined"!==typeof f?d=a[f]=[]:f="mixpanel";d.people=d.people||[];d.toString=function(b){var a="mixpanel";"mixpanel"!==f&&(a+="."+f);b||(a+=" (stub)");return a};d.people.toString=function(){return d.toString(1)+".people (stub)"};k="disable time_event track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config reset people.set people.set_once people.increment people.append people.union people.track_charge people.clear_charges people.delete_user".split(" ");
  for(h=0;h<k.length;h++)e(d,k[h]);a._i.push([b,c,f])};a.__SV=1.2;b=e.createElement("script");b.type="text/javascript";b.async=!0;b.src="undefined"!==typeof MIXPANEL_CUSTOM_LIB_URL?MIXPANEL_CUSTOM_LIB_URL:"file:"===e.location.protocol&&"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js".match(/^\/\//)?"https://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js":"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";c=e.getElementsByTagName("script")[0];c.parentNode.insertBefore(b,c)}})(document,window.mixpanel||[]);
  mixpanel.init("1919205b2da72e4da3b9b6639b444d59");</script>
  <!-- end Mixpanel -->
</head>

<body>
  <svg style="display: none;">
    <defs>
      <symbol id="linkIcon" fill="#706d77" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
          <path d="M0 0h24v24H0z" fill="none"/>
          <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>
      </symbol>
    </defs>
  </svg>

  <input type="checkbox" id="nav-trigger" class="nav-trigger" />
  <label for="nav-trigger" class="navicon-button x">
    <div class="navicon"></div>
  </label>

  <label for="nav-trigger" class="overlay"></label>

  <div class="top-nav-wrapper">
    <ul>
      <li >
        <a href="index.html">
          
            <svg fill="#6D6D6D" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
              <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
              <path d="M0 0h24v24H0z" fill="none"/>
            </svg>
          
          
        </a>
      </li>

      

    </ul>
  </div>

  <nav>
    <h3 class="reference-title">
      Endpoints by Classroom Tech Tools.
    </h3>

    

    <h3>Classes</h3><ul><li id="Batch-nav"><a href="Batch.html">Batch</a><ul class='methods'><li data-type="method" id="Batch-add-nav"><a href="Batch.html#add">add</a></li><li data-type="method" id="Batch-fetchAll-nav"><a href="Batch.html#fetchAll">fetchAll</a></li></ul></li><li id="DiscoveryCache-nav"><a href="DiscoveryCache.html">DiscoveryCache</a></li><li id="Endpoint-nav"><a href="Endpoint.html">Endpoint</a><ul class='methods'><li data-type="method" id="Endpoint-createRequest-nav"><a href="Endpoint.html#createRequest">createRequest</a></li><li data-type="method" id="Endpoint-getBaseUrl-nav"><a href="Endpoint.html#getBaseUrl">getBaseUrl</a></li><li data-type="method" id="Endpoint-httpdelete-nav"><a href="Endpoint.html#httpdelete">httpdelete</a></li><li data-type="method" id="Endpoint-httpget-nav"><a href="Endpoint.html#httpget">httpget</a></li><li data-type="method" id="Endpoint-httppatch-nav"><a href="Endpoint.html#httppatch">httppatch</a></li><li data-type="method" id="Endpoint-httppost-nav"><a href="Endpoint.html#httppost">httppost</a></li><li data-type="method" id="Endpoint-httpput-nav"><a href="Endpoint.html#httpput">httpput</a></li></ul></li><li id="Oauth-nav"><a href="Oauth.html">Oauth</a></li><li id="Request-nav"><a href="Request.html">Request</a><ul class='methods'><li data-type="method" id="Request-addHeader-nav"><a href="Request.html#addHeader">addHeader</a></li><li data-type="method" id="Request-addQuery-nav"><a href="Request.html#addQuery">addQuery</a></li><li data-type="method" id="Request-clearFields-nav"><a href="Request.html#clearFields">clearFields</a></li><li data-type="method" id="Request-clearQuery-nav"><a href="Request.html#clearQuery">clearQuery</a></li><li data-type="method" id="Request-fetch-nav"><a href="Request.html#fetch">fetch</a></li><li data-type="method" id="Request-getParams-nav"><a href="Request.html#getParams">getParams</a></li><li data-type="method" id="Request-getUrl-nav"><a href="Request.html#getUrl">getUrl</a></li><li data-type="method" id="Request-setFields-nav"><a href="Request.html#setFields">setFields</a></li></ul></li><li id="Response-nav"><a href="Response.html">Response</a><ul class='methods'><li data-type="method" id="Response-getRequest-nav"><a href="Response.html#getRequest">getRequest</a></li><li data-type="method" id="Response-getStatusCode-nav"><a href="Response.html#getStatusCode">getStatusCode</a></li><li data-type="method" id="Response-getText-nav"><a href="Response.html#getText">getText</a></li><li data-type="method" id="Response-isOk-nav"><a href="Response.html#isOk">isOk</a></li></ul></li><li id="Utils-nav"><a href="Utils.html">Utils</a><ul class='methods'><li data-type="method" id="Utils-interpolate-nav"><a href="Utils.html#interpolate">interpolate</a></li><li data-type="method" id="Utils-makeQueryString-nav"><a href="Utils.html#makeQueryString">makeQueryString</a></li><li data-type="method" id="Utils-translateToTemplate-nav"><a href="Utils.html#translateToTemplate">translateToTemplate</a></li></ul></li></ul><h3 id="global-nav">Global</h3><ul><li><a href="global.html#batch">batch</a></li><li><a href="global.html#createGoogEndpoint">createGoogEndpoint</a></li><li><a href="global.html#createGoogEndpointWithOauth">createGoogEndpointWithOauth</a></li><li><a href="global.html#createRequest">createRequest</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getOauthAsMe">getOauthAsMe</a></li><li><a href="global.html#interpolate">interpolate</a></li><li><a href="global.html#iterator">iterator</a></li><li><a href="global.html#makeGoogOauthService">makeGoogOauthService</a></li><li><a href="global.html#module">module</a></li><li><a href="global.html#post">post</a></li><li><a href="global.html#resolveUrlInterpolation">resolveUrlInterpolation</a></li></ul>
  </nav>

  <div id="main">
    
      <h1 class="page-title">
        modules/Library.js
      </h1>
    

    
      

<section>
  <article>
    <pre class="prettyprint source linenums"><code>import {Enforce} from '@classroomtechtools/enforce_arguments';
import {OAuth2} from './lib/Oauth2.js';

/**
 * Class used for cases where oauth is send as "me", where `SciptApp.getOAuthToken` is appropriate auth. The token is actually retrieved on the call itself, rather than at endpoint creation (otherwise it might timeout)
 * @property {String} token
 */
class Oauth {
  get token () {
    return ScriptApp.getOAuthToken();
  }
}


/**
 * An object that represents a collection of requests that will be asynchronously retrieved. Use `add` to add request objects, and then `fetchAll` which interacts with APIs concurrently and return them all. The responses will be in the same order as the requests.
 *
 * You can also iterate over this object with `for â€¦ of` syntax, and it does so by chunking the requests, passing back time to the caller to process.
 * @example
// create the object
const batch = Endpoints.batch();

// add request objects
batch.add({request});  // Request

// use `fetchAll` to grab them all at once
const responses = batch.fetchAll();

// get the json
const response = responses[0];
Logger.log(response.json);

// or
// iterate over the object and get one at a time
for (const response of batch) {
  Logger.logger(response.json);
}
 * @class
 */
class Batch {
  /**
   * Usually created with call to `Endpoints.batch`
   * @return {Batch}
   * @param {Number} [rateLimit=50] - The maximum number, per second, that the endpoint can take before raising 429. error. (This often applies per IP address)
   * @param {Date} [lastExecutionDate=null] - Uses this as basis for understanding how much longer it has for a second to elapse. In most cases, safest to leave as `null`
   * @param {Boolean} [verbose=false] - set to true if you want to see messages indicating when it's sleeping in order to ensure the rate limit isn't exceeded
   * @example
const batch = Endpoints.batch();
batch.add({request});  // Request
const responses = batch.fetchAll();
const response = responses[0];
Logger.log(response.json);
// or
for (const response of batch) {
  Logger.logger(response.json);
}
   */
   constructor ({rateLimit=50, lastExecutionDate=null, verbose=false}={}) {
    Enforce.named(arguments, {rateLimit: 'number', lastExecutionDate: 'any'}, 'Batch#constructor');
    this.reset(lastExecutionDate);
    this.rateLimit = rateLimit;
    this.verbose = verbose;
  }

  reset (lastExecutionDate) {
    this.queue = [];
    this._after = [];
    this._timing = {lastExecutionDate};
  }

  /**
   * Add request to batch queue
   * @param {Request} request - An Endpoints.Request object
   */
  add ({request}={}) {
    Enforce.named(arguments, {request: Namespace.Request}, 'Batch#add');
    this.queue.push(request);
  }

  /**
   * Use UrlFetchApp to reach out to the internet. Returns Response objects in same order as requests. You need to use `json` property to get the data result. Note that Response objects also have `request` property, which can be used to debug, or rebuild the original request, if necessary. Any mixin classes that are used on request creation will be available on the response object.

   Handles 429 errors smartly. Instead of trying again with all of the requests, its subsequent attempt will only fetch those that had 429. Note that the current algorithm assumes these batch requests are going to the same endpoint. TODO: better algorithm not assuming same endpoint
   * @return {Response[]}
   * @example
// Make list of response jsons
batch.fetchAll().map(response => response.json);
   * @example
// Make list of original request urls
batch.fetchAll().map(response => response.request.url);
   * @example
// request with mixins
const req = Endpoints.createRequest('get', {}, {
  param: 1
});
const batch = Endpoints.batch();
batch.add({request: req});
const responses = batch.fetchAll();
const response = responses[0];
Logger.log(response.param);  // 1
   */
  fetchAll () {
    const obj = {retry: 0, start: 0, stoppedAt: this.queue.length};
    let collated = [];

    do {
      if (obj.stoppedAt &lt; this.queue.length) {
        obj.start = obj.stoppedAt;
        obj.stoppedAt = this.queue.length;
        this.verbose &amp;&amp; Logger.log('429 hit rate encountered in Batch#fetchAll, sleeping for ' + (obj.retry / 1000) + ' seconds.');
        Utilities.sleep(obj.retry);
      }

      const responses = UrlFetchApp.fetchAll(
        this.queue.slice(obj.start).map(
          request => {
            const {params} = request.getParams({embedUrl: true});
            return params;
          }
        )
      ).map( (response, idx) => {
          const request = this.queue[idx];
          const response_ = new Response({response, request});
          if (response_.statusCode === 429) {
            obj.retry = Math.max(obj.retry, response_.x_ratelimit_reset);  //
            obj.stoppedAt = Math.min(obj.stoppedAt, idx);
            return null;
          }
          return response_;
        });

        //process
        const nulled = responses.indexOf(null);
        if (nulled === -1) {
          Array.prototype.push.apply(collated, responses);
          obj.rety = 0;
          obj.start = 0;
        } else {
          Array.prototype.push.apply(collated, responses.slice(0, nulled));
        }

    } while (obj.retry > 0);

    // add any .after
    Array.prototype.push.apply(collated, this._after);
    this.reset();

    return collated;
  }

  /**
   * Respecting the rate limit (default value is low, pass higher value in constructor),
   * fetch everything in chunks, returning each response one-by-one, making processing easier.
   * Particularly useful if you know the rate limit (or just choose a sensible one)
   * @name iterator
   * @method
   * @yields {Response}
   * @example
const batch = Endpoints.batch(200);  // 200 hits per second
for (let i=0; i&lt;10000; i++) {
  const request = ...;
  batch.add(request);   // add 10,000 requests
}
for (const response of batch) {
  // you'll get each response one-by-one, but it'll chunk
  // by 200, and will wait for second to expire before the next chunk
  Logger.log(response.json);
}
  */
  *[Symbol.iterator] () {
    const size = this.rateLimit || 50,
          oneSecond = 1000;
    const len = this.queue.length;
    for (let idx=0; idx &lt; len; idx += size) {
      const chunk = this.queue.slice(idx, idx + size);
      const lastTime = this._timing.lastExecutionDate || new Date(9999999999999), now = new Date();
      const delta = now.getTime() - lastTime.getTime();
      if ( delta &lt; oneSecond &amp;&amp; delta > 0 ) {
        this.verbose &amp;&amp; Logger.log("Sleeping for " + ((oneSecond - delta) / 1000) + " seconds to avoid rate limit of " + this.rateLimit);
        Utilities.sleep(oneSecond - delta + 10);
      }

      // todo: abstract this a bit more, checking for 429
      const fetchAppResponses = UrlFetchApp.fetchAll(
        chunk.map(
          request => {
            const {params} = request.getParams({embedUrl: true});
            return params;
          }
        )
      );

      // save for loop
      this._timing.lastExecutionDate = new Date();

      // now prepare the responses so the body can make due with them
      const responses = fetchAppResponses.map( (response, idx) => {
        const request = chunk[idx];
        const response_ = new Response({response, request});
        return response_;
      });

      // and hand back the time to the calling body
      for (const response of responses) {
        yield response;
      }
    }
  }
}

/**
 * @name Batch#iterator
 * @method
 * @memberOf Batch
 # @description   Respecting the rate limit (default value is low, pass higher value in constructor), fetch everything in chunks, returning each response one-by-one, making processing easier. Particularly useful if you know the rate limit (or just choose a sensible one)
 * @yields {Response}
 * @example
const batch = Endpoints.batch(200);  // 200 hits per second
for (let i=0; i&lt;10000; i++) {
  const request = ...;
  batch.add(request);   // add 10,000 requests
}
for (const response of batch) {
  // you'll get each response one-by-one, but it'll chunk
  // by 200, and will wait for second to expire before the next chunk
  Logger.log(response.json);
}
 */



/**
 * DiscoveryCache - Used internally to save in cache the various url paths to endpoints with the Google Discovery Service. Fun fact: It actually uses this library's `httpget` to interact with `https://www.googleapis.com/discovery/v1/apis/`
 */
class DiscoveryCache {
    constructor () {
      this.cache = CacheService.getScriptCache();
    }

    getUrl ({name, version, resource, method}={}) {
      const {Namespace} = Import;
      const key = `${name}${version}${resource}${method}`;
      let data = this.cache.get(key);
      let ret = null;
      if (data) {
        console.log({key, fromCache: true});
        return data;
      }
      data = this.getEndpoint(name, version).json;

      if (data.error) {
        throw new Error(`No "${name}" with version "${version}" found. Perhaps spelling is wrong?`);
      }

      if (resource.indexOf('.') === -1) {
        // straight forward
        if (!data.resources[resource]) {
          throw new Error(`No resource "${resource}" found in ${name}${version}; only has: ${Object.keys(data.resources)}`);
        }
        if (!data.resources[resource].methods[method]) {
          throw new Error(`No method "${method}" found in resource "${resource}" of "${name}${version}", only: ${Object.keys(data.resources[resource].methods)} available`);
        }
        ret = data.baseUrl + data.resources[resource].methods[method].path;
      } else {
        // resources can be dot-noted in order to resolve a path, e.g. sheets.spreadsheets.values, sheets.spreadsheets.developerMetadata
        let resources = data;
        resource.split('.').forEach(function (res) {
          resources = resources.resources[res];
        });
        ret = data.baseUrl + resources.methods[method].path;
      }

      this.cache.put(key, ret, 21600);  // max is 6 hours
      console.log({key, fromCache: false});
      return ret;
    }

    getEndpoint(name, version) {
      return new Namespace.Endpoint().httpget({url: `https://www.googleapis.com/discovery/v1/apis/${name}/${version}/rest`}).fetch();
    }

}


/**
 * Class that fills in Endpoint.utils namespace
 * provides utility methods used throughout the library, can be exported
 */
class Utils {
  validateDiscovery ({name=null, version=null, resource=null, method=null}={}) {
    return name &amp;&amp; version &amp;&amp; resource &amp;&amp; method;
  }

  /**
   * Like js template literal, replace '${here}' with {here: 'there'}  // "there"
   * Usage: interpolate("${greet}, ${noun}", {greet: 'hello', noun: 'world'})  // "Hello, World"
   * @param {String} baseString - A string with ${x} placeholders
   * @param {Object} params - key/value for substitution
   * @return {String}
   */
  interpolate (baseString, params) {
    const names = Object.keys(params);
    const vals = Object.values(params);
    try {
      return new Function(...names, `return \`${baseString}\`;`)(...vals);
    } catch (e) {
      throw new Error(`insufficient parameters. Has ${Object.keys(params)} but ${e.message}`);
    }
  }

  /**
   * Convert strings that have {name.subname} pattern to ${name_subname} so can be interpolated
   * Used internally; required since Google APIs use former pattern instead of latter
   */
  translateToTemplate (string) {
    // Use special patterns available in second parameter go from a {} to ${}
    return string.replace(/{\+*([a-zA-Z_.]*?)}/g, function (one, two) {
      return '${' + two.replace('.', '_') + '}';
    });
  }

  /**
   * Convert an obj to string of params used in query strings
   * supports multiple query strings as arrays, e.g.:
   * {fields: [], key: 'value'}  converts to ?key=value - No fields included as it is empty array
   * {arr: ['one', two'], key: 'value'} converts to ?array=one&amp;array=two&amp;key=value
   * @return {String}
   */
  makeQueryString ({...kwargs}={}) {
    const arr = Object.entries(kwargs).reduce(
      function (acc, [key, value]) {
        if (Array.isArray(value)) {
          for (const v of value) {
            acc.push(key + '=' + encodeURIComponent(v));
          }
        } else {
          acc.push(key + '=' + encodeURIComponent(value));
        }
        return acc;
      }, []
    );
    return (arr.length === 0 ? '' : '?' + arr.join('&amp;'))
  }
}

const PRIVATE_OAUTH = Symbol('private_oauth');

/**
 * Request instance. Instances of this class are created with `createRequest`. See below properties for properties and methods available
 * @property {Object} headers - The headers passed in
 * @property {String} method - "get" etc
 * @property {Object} query - what was passed to you
 * @property {Object} pathParams - an object that holds as keys/values what was passed in the second parameter, if any
 */
class Request {

  /**
   * Usually created on your behalf
   * @param {Object} main - the first parameter
   * @param {String} url - the url (normally before query parameters)
   * @param {Any} oauth - oauth object, usually created via Oauth2 lib
   * @param {String} method - http method i.e. 'get' etc
   * @param {Object} headers - http headers
   * @param {Object} query - query parameters
   * @param {Any} mixin - adds properties in mixin object to the request obj via Object.assign
   */
  constructor ({url, oauth, method='get', headers={}, payload={}, query={}}={}, {mixin=null}) {
    Enforce.named(arguments, {url: '!string', oauth: '!any', method: 'string', headers: 'object', payload: 'object', query: 'object', mixin: 'any'});
    this._url = url;
    this.headers = headers;
    this.payload = payload;
    this.method = method;
    this.query = query;
    // standard parameters is quite useful for performance, use is specially
    this._fields = [];
    this[PRIVATE_OAUTH] = oauth;

    if (mixin) Object.assign(this, mixin);
  }

  /**
   * Reach out to the internet with UrlFetchApp, returns Response object. Automatically detects rate limit, pauses, and tries again (just once)
   * @return {Response}
   * @example
const request = Endpoints.createRequest('get', {
  url: 'https://example.com'
});
const response = request.fetch();
Logger.log(response.json);
   */
  fetch () {
    const {url, params: requestObject} = this.url_params({embedUrl: true});
    let response;
    try {
      response = UrlFetchApp.fetch(url, requestObject);
    } catch (e) {
      response = null;
      throw new Error(e.message, {url, requestObject});
    }
    let resp = new Response({response, request: this});

    // auto-detect ratelimits, try again
    if (resp.hitRateLimit) {
      response = UrlFetchApp.fetch(url, requestObject);
      resp = new Response({response, request: this});
    }

    return resp;
  }

  /**
   * Alternative to this.url
   * @return {String}
   */
  getUrl () {
    return this.url;
  }

  /**
   * Calculates url, adding query parameters. In case key fields is non empty, converts with `join(",")` as needed by fields standard query param
   */
  get url () {
    if ( (this._fields || []).length > 0) {
      // convert fields data type from array to string with , delimiter, but don't replace
      return this._url + Endpoint.utils.makeQueryString({...this.query, ...{fields: this._fields.join(',')}});
    }
    return this._url + Endpoint.utils.makeQueryString(this.query);
  }

  /**
   * Copies key in obj to request object so that query parameters are passed on fetch
   * @param {Object} obj - the object that is copied to queries object
   * @example
const request = Endpoints.createRequest('get', {
  url: 'https://example.com'
});
request.addQuery({p: 'str'});
request.url;  // https://exmaple.com?p=str
   */
  addQuery (obj={}) {
    Enforce.positional(arguments, {obj: 'object'}, 'Request#addQuery');
    for (const [key, value] of Object.entries(obj)) {
      this.query[key] = value;
    }
  }

  /**
   * Adds header
   * @param {Object} obj
   */
  addHeader (obj={}) {
    /**
     * Copies key in obj to headers object so
     */
    Enforce.positional(arguments, {obj: 'object'}, 'Request#addHeader');
    for (const [key, value] of Object.entries(obj)) {
      this.headers[key] = value;
    }
  }

  /**
   * Sets `this.query` to empty object
   */
  clearQuery () {
    this.query = {};
  }

  set fields (value=null) {
    Enforce.positional(arguments, {value: 'string'}, 'Request#set_fields');
    this._fields.push(value);
  }

  /**
   * Pushes value to this.query.fields
   * @param {String} value
   */
  setFields (value) {
    this.fields = value;
  }

  /**
   * Sets _fields to empty array
   */
  clearFields () {
    this._fields = [];
  }

  url_params(...params) {
    return this.getParams(...params);
  }

  /**
   * @typedef urlParamsObj
   * @property {String} url - The url including query parameters
   * @property {Object} params - The parameters sent as second parameter to `UrlFetchApp`. Will optionally include a `url` property (when `getParams` is called with `{embedUrl:true}`)
   */


  /**
   * Returns the param object required for UrlFetchApp.fetch or fetchAll
   * @param {bool} embedUrl - if true add `url` property in object (needed for fetchAll)
   * @param {bool} muteExceptions - if true errors will be returned as jsons
   * @returns {urlParamsObj}
   * @example
  const req = Endpoints.createRequest('get', {
    url: 'http://example.com'
  }, {
    query: {p: 'str'}
  });
  const {url, params} = req.getParams();
  Logger.log(url);  // 'http://exmaple.com?p=str'
  Logger.log(params);  // {method: 'get', ...}
   */
  getParams ({embedUrl=false, muteExceptions=true}={}) {
    Enforce.named(arguments, {embedUrl: 'boolean', muteExceptions: 'boolean'}, 'Request#url_params');
    const params = {};

    // calculate url based on queries as needed
    const url = this.url;

    // we'll derive the oauth token upon request, if applicable, here
    // keep backward compatible with Oauth2 lib

    if (this[PRIVATE_OAUTH]) {

      const token = (_ => {
        if (this[PRIVATE_OAUTH].hasAccess) {
          // if our oauth has a method "hasAccess" we know it's using the Oauth lib
          if (this[PRIVATE_OAUTH].hasAccess()) {
            // return the access token (usually the case will do so)
            return this[PRIVATE_OAUTH].getAccessToken();
          }
          // return null if Oauth lib reports no access (in some cases may have problems)
          return null;
        }

        // here oauth is an object (class instance) with token property
        // return that, or null if not present or empty
        return this[PRIVATE_OAUTH].token || null;
      })();
      if (token==null) throw new Error("No authorization");
      this.headers['Authorization'] = `Bearer ${token}`;
    }

    if (Object.keys(this.headers).length > 0) {
      params.headers = this.headers;
    }

    params.muteHttpExceptions = muteExceptions;
    params.method = this.method;
    if (embedUrl) params.url = url;
    if (Object.keys(this.payload).length > 0) {
      params.payload = JSON.stringify(this.payload);
      params.contentType = 'application/json';
    }

    return {url, params};
  }

}


/**
 * Response objects, created on your behalf. Contains both the actual response object returned by `UrlFetchApp` and the params object that was built and sent to `UrlFetchApp`
 */
class Response {

  /**
   * Response object, created in Request#fetch
   * @param {Object} param
   * @param {Object} param.response
   * @param {Object} param.request
   */
  constructor ({response=null, request=null}={}) {
    Enforce.named(arguments, {response: 'object', request: Namespace.Request}, 'Response#constructor');
    this.response = response;
    this.request = request;

    // By default, if response cannot be parsed to json we'll send back a json with error information instead of throwing error
    this.catchUnparseableJsonResponse = true;
  }

  /**
   * Return the plain text of the response (getContentText)
   * @return {String}
   */
  getText () {
     return this.text;
  }

  /**
   * Return the plain text of the response (getContentText)
   */
  get text () {
    return this.response.getContentText();
  }

  /**
   * Returns the parsed text of the response. By default, if an error is encountered in call to `JSON.parse`, the returned json has an `error` property which in turn has `status`, `message`, `charset`, and `mime` properties.
   * @throws {Error} if cannot be parsed as json but only if `this.catchUnparseableJsonResponse`
   */
  get json () {

    const text = this.text;
    let result;
    try {
      return JSON.parse(text);
    } catch (err) {
      if (this.catchUnparseableJsonResponse) {
        // return a json with error message instead, as usually does Google APIs
        const contentType = this.headers["Content-Type"];
        const [mime, charset] = contentType.split(';').map(str => str.trim());
        return {
          error: {
            status: this.statusCode,
            message: err.message,
            charset: charset || null,
            mime: mime || null,
          },
          text
        }
      }
      throw new Error(err);
    }

    return result;
  }

  /**
   * Same as getAllHeaders
   * @return {Object}
   */
  get headers () {
    return this.response.getAllHeaders();
  }

  getHeaders () {
    return this.headers;
  }

  /**
   * Same as getRepsonseCode, 200 is success
   * @return {Number}
   */
  get statusCode () {
    return this.response.getResponseCode();
  }

  /**
   * Returns this.statusCode
   * @return {Number}
   */
  getStatusCode () {
    return this.statusCode;
  }

  /**
   * Returns true if statusCode == 200
   * @return {Boolean}
   */
  get ok () {
    return this.statusCode === 200;
  }

  /**
   * Returns true if the `statusCode` of the repsonse object is 200
   * @return {Boolean}
   */
  isOk () {
    return this.ok;
  }

  get x_ratelimit_reset () {
    let header_reset_at = this.headers['x-ratelimit-reset'];
    header_reset_at = header_reset_at.replace(" UTC", "+0000").replace(" ", "T");
    const reset_at = new Date(header_reset_at).getTime();
    const utf_now = new Date().getTime();
    return reset_at - utf_now + 1;
  }

  /**
   * Returns false if the response is anything except `429`. Returns true only after sleeping for how many milliseconds as indicated in the `x-ratelimit-reset` header. Can be used to retry. Used internally by `Request#fetch` to avoid rate limitations.
   */
  get hitRateLimit () {
    if (this.statusCode === 429) {
      const milliseconds = this.x_ratelimit_reset;
      if (milliseconds > 0) {
        this.verbose &amp;&amp; Logger.log('429 rate limit encountered in fetch, sleeping for ' + (milliseconds / 1000) + ' seconds')
        Utilities.sleep(milliseconds);
      }
      return true;
    }
    return false;
  }

  /**
   * Returns the {@link https://developers.google.com/apps-script/reference/url-fetch/http-response HTTPResponse} object as returned by `UrlFetchApp#fetch`
   * @return {HTTPResponse}
   */
  getRequest () {
    return this.request.getParams().params;
  }
}


/**
 * Abstraction of UrlFectchApp, class returned by `Endpoints.module`. Can be used for more extensibility
 * @class
 */
class Endpoint {

  /**
   * Normally you'll create an instance of this class indirectly by interfacing with the API. You can retrieve this class object with call to `Endpoints.module()`;
   * @param {Object}        [base]
   * @param {String}        [base.baseUrl] The basic url, usually with {name} that is replaced by interpolation
   * @param {String|Object} [base.oauth] set to "{oauth='me'}" to automatically work with user's account
   * @param {Object}        [base.discovery]
   * @param {Object}        [stickies] permanent values for options
   * @param {Object}        [stickies.stickyHeaders] permanent headers for any created requests
   * @param {Object}        [stickies.stickyQuery] permanent queries on any created requests
   * @param {Object}        [stickies.payload] payload for any created requests
   */
  constructor ({baseUrl=null, oauth=null, discovery={}}={}, {stickyHeaders={}, stickyQuery={}, stickyPayload={}}={}) {
    Enforce.named(arguments, {baseUrl: 'string', oauth: 'any', discovery: 'object', stickyHeaders: 'object', stickyQuery: 'object', stickyPayload: 'object'}, 'Endpoints.constructor');
    this.disc = null;
    this.baseUrl = baseUrl;
    this.stickyHeaders = stickyHeaders;
    this.stickyQuery = stickyQuery;
    this.stickyPayload = stickyPayload;
    this.oauth = oauth;
    if (Object.keys(discovery).length > 0 &amp;&amp; Endpoint.utils.validateDiscovery(discovery)) {
      this.disc = new DiscoveryCache();
      this.baseUrl = Endpoint.utils.translateToTemplate( this.disc.getUrl(discovery) );
    }

    // set oauth to a basic class
    if (this.oauth === 'me') {
      this.oauth = new Oauth();
    }
  }

  /**
   * An endpoint's baseUrl property is a string with placeholders
   */
  getBaseUrl () {
    return this.baseUrl;
  }

  /**
   * Creates any http request. Used by the `http*` methods.
   * @param {String} method
   * @param {Object} base
   * @param {String} [base.url]
   * @param {Object} [base.pathParams] - replace ${placeholders} by key/values found in baseUrl
   * @param {Object} [options]
   * @param {Object} [options.query]
   * @param {Object} [options.payload]
   * @param {Object} [options.headers]
   * @param {Object} [advanced]
   * @param {Any}    [advanced.mixin] mixin pattern on request object
   * @return {Request}
   */
  createRequest (method, {url=null, ...pathParams}={}, {query={}, payload={}, headers={}}={}, mixin={}) {
    const options = {};

    // check for what it has been passed
    if (Object.keys(pathParams).length > 0) {
      if (!url &amp;&amp; !this.baseUrl) throw new TypeError("createRequest requires a url named parameter in the second parameter");
      if (this.baseUrl &amp;&amp; url) throw new TypeError("createRequest has been passed url when baseUrl has already been defined.");
      options.url = Endpoint.utils.interpolate(this.baseUrl || url, pathParams);
    } else if (url !== null) {
      options.url = url;
    } else {
      options.url = this.baseUrl;
    }
    options.method = method;
    options.headers = {...this.stickyHeaders, ...headers};  // second overwrites
    options.payload = {...this.stickyPayload, ...payload};
    options.query = {...this.stickyQuery, ...query};
    options.oauth = this.oauth;
    mixin.pathParams = pathParams;

    return new Request(options, {mixin});
  }

  /**
   * Creates http get request
   * @param {Object} pathParams - replace ${placeholders} by key/values
   * @param {Object} [options]
   * @param {Object} [options.query]
   * @param {Object} [options.payload]
   * @param {Object} [options.headers]
   * @return {Request}
   */
  httpget ({...pathParams}={}, {...options}={}, mixin={}) {
    return this.createRequest('get', pathParams, options, mixin);
  }

  /**
   * Creates http post request
   * @param {Object} pathParams - replace ${placeholders} by key/values
   * @param {Object} [options]
   * @param {Object} [options.query]
   * @param {Object} [options.payload]
   * @param {Object} [options.headers]
   * @return {Request}
   */
  httppost ({...pathParams}={}, {...options}={}) {
    return this.createRequest('post', pathParams, options);
  }

  /**
   * Creates http put request
   * @param {Object} pathParams - replace ${placeholders} by key/values
   * @param {Object} [options]
   * @param {Object} [options.query]
   * @param {Object} [options.payload]
   * @param {Object} [options.headers]
   * @return {Request}
   */
  httpput ({...pathParams}={}, {...options}={}) {
    return this.createRequest('put', pathParams, options);
  }

  /**
   * Creates http patch request
   * @param {Object} pathParams - replace ${placeholders} by key/values
   * @param {Object} [options]
   * @param {Object} [options.query]
   * @param {Object} [options.payload]
   * @param {Object} [options.headers]
   * @return {Request}
   */
  httppatch ({...pathParams}={}, {...options}={}) {
    return this.createRequest('patch', path, options);
  }

  /**
   * Creates http delete request
   * @param {Object} pathParams - replace ${placeholders} by key/values
   * @param {Object} [options]
   * @param {Object} [options.query]
   * @param {Object} [options.payload]
   * @param {Object} [options.headers]
   * @return {Request}
   */
  httpdelete({...pathParams}={}, {...options}={}) {
    return this.createRequest('delete', pathParams, options);
  }

  static get utils () {
    return new Utils();
  }

  static discovery ({name, version, resource, method}={}, {oauth="me"}={}) {
    const discovery = {
      name: name,
      version: version,
      resource: resource,
      method: method
    };
    return new Endpoint({oauth, discovery});
  }

  static googOauthService ({service = null, email = null, privateKey = null, scopes = null}) {
    const oauthService = OAuth2.createService(service)
                      .setTokenUrl('https://accounts.google.com/o/oauth2/token')
                      .setIssuer(email)
                      .setPrivateKey(privateKey)
                      .setPropertyStore(PropertiesService.getUserProperties())
                      .setScope(scopes);
    return oauthService;
  }

  static batchRequests ({...kwargs}={}) {
    const b = new Batch();
    const r = new Endpoint(kwargs);
    return {batch: b, request: r};
  }
}

const Namespace = {Endpoint, Response, Batch, Request, Oauth};
export {Namespace};
</code></pre>
  </article>
</section>

    


  </div>

  <br class="clear">

  <footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a>
  </footer>

  <script src="scripts/linenumber.js"></script>
  <script src="scripts/pagelocation.js"></script>

  

</body>
</html>
